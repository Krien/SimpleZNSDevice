<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SimpleZNSDevice: szd.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SimpleZNSDevice
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_c5d7e2152c3dfb9ad8f301e36bd35b77.html">szd</a></li><li class="navelem"><a class="el" href="dir_305442143dd05d675fed34691c64c5fa.html">core</a></li><li class="navelem"><a class="el" href="dir_d4385a4bf172c9255cc7fceec93eb069.html">include</a></li><li class="navelem"><a class="el" href="dir_c6a22b390c2abeb6e4e07f1c5da891f1.html">szd</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">szd.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="szd__namespace_8h_source.html">szd/szd_namespace.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="szd__status__code_8h_source.html">szd/szd_status_code.h</a>&quot;</code><br />
<code>#include &lt;pthread.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for szd.h:</div>
<div class="dyncontent">
<div class="center"><img src="szd_8h__incl.png" border="0" usemap="#aszd_8h" alt=""/></div>
<map name="aszd_8h" id="aszd_8h">
<area shape="rect" title=" " alt="" coords="295,5,351,32"/>
<area shape="rect" href="szd__namespace_8h.html" title=" " alt="" coords="5,155,169,181"/>
<area shape="rect" href="szd__status__code_8h.html" title=" " alt="" coords="79,80,245,107"/>
<area shape="rect" title=" " alt="" coords="218,155,301,181"/>
<area shape="rect" title=" " alt="" coords="321,80,405,107"/>
<area shape="rect" title=" " alt="" coords="429,80,500,107"/>
<area shape="rect" title=" " alt="" coords="525,80,591,107"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="szd_8h__dep__incl.png" border="0" usemap="#aszd_8hdep" alt=""/></div>
<map name="aszd_8hdep" id="aszd_8hdep">
<area shape="rect" title=" " alt="" coords="591,5,647,32"/>
<area shape="rect" href="szd__buffer_8hpp.html" title=" " alt="" coords="561,80,677,107"/>
<area shape="rect" href="szd__circular__log_8hpp.html" title=" " alt="" coords="493,379,648,405"/>
<area shape="rect" href="szd__fragmented__log_8hpp.html" title=" " alt="" coords="102,379,285,405"/>
<area shape="rect" href="szd__freezone__list_8hpp.html" title=" " alt="" coords="112,304,275,331"/>
<area shape="rect" href="szd__log_8hpp.html" title=" " alt="" coords="659,304,757,331"/>
<area shape="rect" href="szd__once__log_8hpp.html" title=" " alt="" coords="777,379,914,405"/>
<area shape="rect" href="szd__channel_8hpp.html" title=" " alt="" coords="453,155,584,181"/>
<area shape="rect" href="szd__channel__factory_8hpp.html" title=" " alt="" coords="301,229,483,256"/>
<area shape="rect" href="szd__device_8hpp.html" title=" " alt="" coords="987,80,1109,107"/>
<area shape="rect" href="szd__test__util_8hpp_source.html" title=" " alt="" coords="985,155,1117,181"/>
</map>
</div>
</div>
<p><a href="szd_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDeviceOptions.html">DeviceOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to pass to the ZNS device on initialisation.  <a href="structDeviceOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDeviceOpenOptions.html">DeviceOpenOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to pick when opening a device.  <a href="structDeviceOpenOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDeviceInfo.html">DeviceInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds general information about a ZNS device.  <a href="structDeviceInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDeviceManagerInternal.html">DeviceManagerInternal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not touch, is to be used by Device Manager only.  <a href="structDeviceManagerInternal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDeviceManager.html">DeviceManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General structure that aids in managing one ZNS namespace. The core structure in SimpleZnsDevice.  <a href="structDeviceManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structQPair.html">QPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread unsafe I/O channel. Can be used for writing and reading of data.  <a href="structQPair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCompletion.html">Completion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for synchronous I/O calls to communicate (QPairs and their callbacks).  <a href="structCompletion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structProbeInformation.html">ProbeInformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used for identifying devices.  <a href="structProbeInformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDeviceTarget.html">DeviceTarget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that is used when looking for a device by trid.  <a href="structDeviceTarget.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a84ab7455423fd9c5787957f814742291"><td class="memItemLeft" align="right" valign="top"><a id="a84ab7455423fd9c5787957f814742291"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SZD_H</b></td></tr>
<tr class="separator:a84ab7455423fd9c5787957f814742291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da93f54d45bc68df7cd6e8661088559"><td class="memItemLeft" align="right" valign="top"><a id="a3da93f54d45bc68df7cd6e8661088559"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_TRADDR_LENGTH</b>&#160;&#160;&#160;0x100</td></tr>
<tr class="separator:a3da93f54d45bc68df7cd6e8661088559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ca23c85c6385ea64dfa919547104f2"><td class="memItemLeft" align="right" valign="top"><a id="a70ca23c85c6385ea64dfa919547104f2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_DEVICE_COUNT</b>&#160;&#160;&#160;0x100</td></tr>
<tr class="separator:a70ca23c85c6385ea64dfa919547104f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7f3694b717c5d402a9a7e45da7783b26"><td class="memItemLeft" align="right" valign="top"><a id="a7f3694b717c5d402a9a7e45da7783b26"></a>
typedef struct spdk_nvme_transport_id&#160;</td><td class="memItemRight" valign="bottom"><b>t_spdk_nvme_transport_id</b></td></tr>
<tr class="separator:a7f3694b717c5d402a9a7e45da7783b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45806fd2e77ea3d9c99a4751998d9713"><td class="memItemLeft" align="right" valign="top"><a id="a45806fd2e77ea3d9c99a4751998d9713"></a>
typedef struct spdk_nvme_ctrlr&#160;</td><td class="memItemRight" valign="bottom"><b>t_spdk_nvme_ctrlr</b></td></tr>
<tr class="separator:a45806fd2e77ea3d9c99a4751998d9713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650c528dafddc9d9b8d1813dbb05cfa1"><td class="memItemLeft" align="right" valign="top"><a id="a650c528dafddc9d9b8d1813dbb05cfa1"></a>
typedef struct spdk_nvme_ctrlr_opts&#160;</td><td class="memItemRight" valign="bottom"><b>t_spdk_nvme_ctrlr_opts</b></td></tr>
<tr class="separator:a650c528dafddc9d9b8d1813dbb05cfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd16e44413e183a8867a467bf5c49e5"><td class="memItemLeft" align="right" valign="top"><a id="a9bd16e44413e183a8867a467bf5c49e5"></a>
typedef struct spdk_nvme_ns&#160;</td><td class="memItemRight" valign="bottom"><b>t_spdk_nvme_ns</b></td></tr>
<tr class="separator:a9bd16e44413e183a8867a467bf5c49e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b7a462ac159a6a631aaaec5661a699"><td class="memItemLeft" align="right" valign="top"><a id="a38b7a462ac159a6a631aaaec5661a699"></a>
typedef struct spdk_nvme_qpair&#160;</td><td class="memItemRight" valign="bottom"><b>t_spdk_nvme_qpair</b></td></tr>
<tr class="separator:a38b7a462ac159a6a631aaaec5661a699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f0e772f317ed62be2905985f13ac90"><td class="memItemLeft" align="right" valign="top"><a id="ac6f0e772f317ed62be2905985f13ac90"></a>
typedef struct spdk_nvme_cpl&#160;</td><td class="memItemRight" valign="bottom"><b>t_spdk_nvme_cpl</b></td></tr>
<tr class="separator:ac6f0e772f317ed62be2905985f13ac90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5abeb6e27fe360bc834e814594634c"><td class="memItemLeft" align="right" valign="top"><a id="a0a5abeb6e27fe360bc834e814594634c"></a>
typedef struct spdk_nvme_zns_ns_data&#160;</td><td class="memItemRight" valign="bottom"><b>t_spdk_nvme_zns_ns_data</b></td></tr>
<tr class="separator:a0a5abeb6e27fe360bc834e814594634c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455f0d358f83e4250ffe14c1da3e0010"><td class="memItemLeft" align="right" valign="top"><a id="a455f0d358f83e4250ffe14c1da3e0010"></a>
typedef struct spdk_nvme_ns_data&#160;</td><td class="memItemRight" valign="bottom"><b>t_spdk_nvme_ns_data</b></td></tr>
<tr class="separator:a455f0d358f83e4250ffe14c1da3e0010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354f1503bc84d2ff5d0351538178f4cd"><td class="memItemLeft" align="right" valign="top"><a id="a354f1503bc84d2ff5d0351538178f4cd"></a>
typedef struct spdk_nvme_zns_ctrlr_data&#160;</td><td class="memItemRight" valign="bottom"><b>t_spdk_nvme_zns_ctrlr_data</b></td></tr>
<tr class="separator:a354f1503bc84d2ff5d0351538178f4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf4e828ca2ff78166354c22c3eb85bd"><td class="memItemLeft" align="right" valign="top"><a id="afbf4e828ca2ff78166354c22c3eb85bd"></a>
typedef struct spdk_nvme_ctrlr_data&#160;</td><td class="memItemRight" valign="bottom"><b>t_spdk_nvme_ctrlr_data</b></td></tr>
<tr class="separator:afbf4e828ca2ff78166354c22c3eb85bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af7342bc46d1eab59316ac49b8653c8e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="szd_8h.html#af7342bc46d1eab59316ac49b8653c8e5">szd_init</a> (<a class="el" href="structDeviceManager.html">DeviceManager</a> **manager, <a class="el" href="structDeviceOptions.html">DeviceOptions</a> *options)</td></tr>
<tr class="memdesc:af7342bc46d1eab59316ac49b8653c8e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">inits SPDK and the general device manager, always call ONCE before ANY other function is called.  <a href="szd_8h.html#af7342bc46d1eab59316ac49b8653c8e5">More...</a><br /></td></tr>
<tr class="separator:af7342bc46d1eab59316ac49b8653c8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695f046f9c36616bd492d94f56546505"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="szd_8h.html#a695f046f9c36616bd492d94f56546505">szd_destroy</a> (<a class="el" href="structDeviceManager.html">DeviceManager</a> *manager)</td></tr>
<tr class="memdesc:a695f046f9c36616bd492d94f56546505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the device if open and destroys the manager.  <a href="szd_8h.html#a695f046f9c36616bd492d94f56546505">More...</a><br /></td></tr>
<tr class="separator:a695f046f9c36616bd492d94f56546505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae42d963fff9f81ad88321f3b7ad287"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="szd_8h.html#a5ae42d963fff9f81ad88321f3b7ad287">szd_reinit</a> (<a class="el" href="structDeviceManager.html">DeviceManager</a> **manager)</td></tr>
<tr class="memdesc:a5ae42d963fff9f81ad88321f3b7ad287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only works when device is not NULL, it recreates the device context.  <a href="szd_8h.html#a5ae42d963fff9f81ad88321f3b7ad287">More...</a><br /></td></tr>
<tr class="separator:a5ae42d963fff9f81ad88321f3b7ad287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa391fd5dd04e707bb2911fee07f0b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="szd_8h.html#a2fa391fd5dd04e707bb2911fee07f0b8">szd_probe</a> (<a class="el" href="structDeviceManager.html">DeviceManager</a> *manager, <a class="el" href="structProbeInformation.html">ProbeInformation</a> **probe_info)</td></tr>
<tr class="memdesc:a2fa391fd5dd04e707bb2911fee07f0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">probes all devices that can be attached by SPDK and set probing information for them.  <a href="szd_8h.html#a2fa391fd5dd04e707bb2911fee07f0b8">More...</a><br /></td></tr>
<tr class="separator:a2fa391fd5dd04e707bb2911fee07f0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61aeb40138b4516f8ca6a1315a04710c"><td class="memItemLeft" align="right" valign="top"><a id="a61aeb40138b4516f8ca6a1315a04710c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="szd_8h.html#a61aeb40138b4516f8ca6a1315a04710c">szd_free_probe_information</a> (<a class="el" href="structProbeInformation.html">ProbeInformation</a> *probe_info)</td></tr>
<tr class="memdesc:a61aeb40138b4516f8ca6a1315a04710c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees information from probe information. <br /></td></tr>
<tr class="separator:a61aeb40138b4516f8ca6a1315a04710c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999bc76327ff0f4d5c5a4a3f70f5febd"><td class="memItemLeft" align="right" valign="top"><a id="a999bc76327ff0f4d5c5a4a3f70f5febd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="szd_8h.html#a999bc76327ff0f4d5c5a4a3f70f5febd">szd_open</a> (<a class="el" href="structDeviceManager.html">DeviceManager</a> *manager, const char *traddr, <a class="el" href="structDeviceOpenOptions.html">DeviceOpenOptions</a> *options)</td></tr>
<tr class="memdesc:a999bc76327ff0f4d5c5a4a3f70f5febd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a ZNS device, provided it exists and is a ZNS device. This device is then set as the current device in the manager. <br /></td></tr>
<tr class="separator:a999bc76327ff0f4d5c5a4a3f70f5febd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525a63646d698c4445dd18c8c8c4fb06"><td class="memItemLeft" align="right" valign="top"><a id="a525a63646d698c4445dd18c8c8c4fb06"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="szd_8h.html#a525a63646d698c4445dd18c8c8c4fb06">szd_close</a> (<a class="el" href="structDeviceManager.html">DeviceManager</a> *man)</td></tr>
<tr class="memdesc:a525a63646d698c4445dd18c8c8c4fb06"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the manager holds a device, shut it down and free associated data. <br /></td></tr>
<tr class="separator:a525a63646d698c4445dd18c8c8c4fb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfa70c3160caca1c88129d8d18d753d"><td class="memItemLeft" align="right" valign="top"><a id="afdfa70c3160caca1c88129d8d18d753d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="szd_8h.html#afdfa70c3160caca1c88129d8d18d753d">szd_get_device_info</a> (<a class="el" href="structDeviceInfo.html">DeviceInfo</a> *info, <a class="el" href="structDeviceManager.html">DeviceManager</a> *manager)</td></tr>
<tr class="memdesc:afdfa70c3160caca1c88129d8d18d753d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a device is attached to manager, gets its information and store it in info. <br /></td></tr>
<tr class="separator:afdfa70c3160caca1c88129d8d18d753d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20543f2c42b5e892b24460902b76780f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="szd_8h.html#a20543f2c42b5e892b24460902b76780f">szd_create_qpair</a> (<a class="el" href="structDeviceManager.html">DeviceManager</a> *man, <a class="el" href="structQPair.html">QPair</a> **qpair)</td></tr>
<tr class="memdesc:a20543f2c42b5e892b24460902b76780f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Qpair to be used for I/O oprations.  <a href="szd_8h.html#a20543f2c42b5e892b24460902b76780f">More...</a><br /></td></tr>
<tr class="separator:a20543f2c42b5e892b24460902b76780f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea6e60dda9bdf3b4f6018d20424a36e"><td class="memItemLeft" align="right" valign="top"><a id="a1ea6e60dda9bdf3b4f6018d20424a36e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="szd_8h.html#a1ea6e60dda9bdf3b4f6018d20424a36e">szd_destroy_qpair</a> (<a class="el" href="structQPair.html">QPair</a> *qpair)</td></tr>
<tr class="memdesc:a1ea6e60dda9bdf3b4f6018d20424a36e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the qpair if it is still valid. <br /></td></tr>
<tr class="separator:a1ea6e60dda9bdf3b4f6018d20424a36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ee257fbc2224257ba6ef7a2e83a5f2"><td class="memItemLeft" align="right" valign="top"><a id="a32ee257fbc2224257ba6ef7a2e83a5f2"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="szd_8h.html#a32ee257fbc2224257ba6ef7a2e83a5f2">szd_calloc</a> (uint64_t __allign, size_t __nmemb, size_t __size)</td></tr>
<tr class="memdesc:a32ee257fbc2224257ba6ef7a2e83a5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom calloc that uses DMA logic necessary for SPDK. Must be alligned with the device lba_size (see <a class="el" href="structDeviceInfo.html" title="Holds general information about a ZNS device.">DeviceInfo</a>). <br /></td></tr>
<tr class="separator:a32ee257fbc2224257ba6ef7a2e83a5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10813db77fda34262ed4c3c52faefdd7"><td class="memItemLeft" align="right" valign="top"><a id="a10813db77fda34262ed4c3c52faefdd7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="szd_8h.html#a10813db77fda34262ed4c3c52faefdd7">szd_free</a> (void *buffer)</td></tr>
<tr class="memdesc:a10813db77fda34262ed4c3c52faefdd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom free that can free memory from z_calloc. <br /></td></tr>
<tr class="separator:a10813db77fda34262ed4c3c52faefdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06221d02ad2597c708adbdfba3dc526b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="szd_8h.html#a06221d02ad2597c708adbdfba3dc526b">szd_read</a> (<a class="el" href="structQPair.html">QPair</a> *qpair, uint64_t lba, void *buffer, uint64_t size)</td></tr>
<tr class="memdesc:a06221d02ad2597c708adbdfba3dc526b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads n bytes synchronously from the ZNS device.  <a href="szd_8h.html#a06221d02ad2597c708adbdfba3dc526b">More...</a><br /></td></tr>
<tr class="separator:a06221d02ad2597c708adbdfba3dc526b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec67a963ce83264117248966028b20c"><td class="memItemLeft" align="right" valign="top"><a id="a4ec67a963ce83264117248966028b20c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>szd_read_with_diag</b> (<a class="el" href="structQPair.html">QPair</a> *qpair, uint64_t lba, void *buffer, uint64_t size, uint64_t *nr_reads)</td></tr>
<tr class="separator:a4ec67a963ce83264117248966028b20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4664e9c4a10fed58725d3b2bb7c394"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="szd_8h.html#a9e4664e9c4a10fed58725d3b2bb7c394">szd_append</a> (<a class="el" href="structQPair.html">QPair</a> *qpair, uint64_t *lba, void *buffer, uint64_t size)</td></tr>
<tr class="memdesc:a9e4664e9c4a10fed58725d3b2bb7c394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append z_calloced data synchronously to a zone.  <a href="szd_8h.html#a9e4664e9c4a10fed58725d3b2bb7c394">More...</a><br /></td></tr>
<tr class="separator:a9e4664e9c4a10fed58725d3b2bb7c394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e4ea05301fe3d3edaa25b6428eb07b"><td class="memItemLeft" align="right" valign="top"><a id="a77e4ea05301fe3d3edaa25b6428eb07b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>szd_append_with_diag</b> (<a class="el" href="structQPair.html">QPair</a> *qpair, uint64_t *lba, void *buffer, uint64_t size, uint64_t *nr_appends)</td></tr>
<tr class="separator:a77e4ea05301fe3d3edaa25b6428eb07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a58fc44339c4d312de8d1dd486ba900"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="szd_8h.html#a9a58fc44339c4d312de8d1dd486ba900">szd_append_async</a> (<a class="el" href="structQPair.html">QPair</a> *qpair, uint64_t *lba, void *buffer, uint64_t size, <a class="el" href="structCompletion.html">Completion</a> *completion)</td></tr>
<tr class="memdesc:a9a58fc44339c4d312de8d1dd486ba900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append z_calloced data asynchronously to a zone.  <a href="szd_8h.html#a9a58fc44339c4d312de8d1dd486ba900">More...</a><br /></td></tr>
<tr class="separator:a9a58fc44339c4d312de8d1dd486ba900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db6e0d47e44406b82d4a659a8738c00"><td class="memItemLeft" align="right" valign="top"><a id="a5db6e0d47e44406b82d4a659a8738c00"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>szd_append_async_with_diag</b> (<a class="el" href="structQPair.html">QPair</a> *qpair, uint64_t *lba, void *buffer, uint64_t size, uint64_t *nr_appends, <a class="el" href="structCompletion.html">Completion</a> *completion)</td></tr>
<tr class="separator:a5db6e0d47e44406b82d4a659a8738c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2022870b58ebe91ce2c76c04a7b553"><td class="memItemLeft" align="right" valign="top"><a id="a8a2022870b58ebe91ce2c76c04a7b553"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="szd_8h.html#a8a2022870b58ebe91ce2c76c04a7b553">szd_poll_async</a> (<a class="el" href="structQPair.html">QPair</a> *qpair, <a class="el" href="structCompletion.html">Completion</a> *completion)</td></tr>
<tr class="memdesc:a8a2022870b58ebe91ce2c76c04a7b553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be used on an asynchronously function to ensure that is synced to the storage. <br /></td></tr>
<tr class="separator:a8a2022870b58ebe91ce2c76c04a7b553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4d91a66e448a7887ac1390fd46b680"><td class="memItemLeft" align="right" valign="top"><a id="a3c4d91a66e448a7887ac1390fd46b680"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>szd_poll_once</b> (<a class="el" href="structQPair.html">QPair</a> *qpair, <a class="el" href="structCompletion.html">Completion</a> *completion)</td></tr>
<tr class="separator:a3c4d91a66e448a7887ac1390fd46b680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1aa70052a1e2d205df5e006d2525f14"><td class="memItemLeft" align="right" valign="top"><a id="aa1aa70052a1e2d205df5e006d2525f14"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>szd_poll_once_raw</b> (<a class="el" href="structQPair.html">QPair</a> *qpair)</td></tr>
<tr class="separator:aa1aa70052a1e2d205df5e006d2525f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f56bc7a4bda5299058503586f81d6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="szd_8h.html#af2f56bc7a4bda5299058503586f81d6a">szd_reset</a> (<a class="el" href="structQPair.html">QPair</a> *qpair, uint64_t slba)</td></tr>
<tr class="memdesc:af2f56bc7a4bda5299058503586f81d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a zone synchronously, allowing it to be reused.  <a href="szd_8h.html#af2f56bc7a4bda5299058503586f81d6a">More...</a><br /></td></tr>
<tr class="separator:af2f56bc7a4bda5299058503586f81d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8867cdd2b254941230d958482c7abeb3"><td class="memItemLeft" align="right" valign="top"><a id="a8867cdd2b254941230d958482c7abeb3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="szd_8h.html#a8867cdd2b254941230d958482c7abeb3">szd_reset_all</a> (<a class="el" href="structQPair.html">QPair</a> *qpair)</td></tr>
<tr class="memdesc:a8867cdd2b254941230d958482c7abeb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets all zones within min and max lba. <br /></td></tr>
<tr class="separator:a8867cdd2b254941230d958482c7abeb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8866709798a666f4dabfb3cf74ed4930"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="szd_8h.html#a8866709798a666f4dabfb3cf74ed4930">szd_finish_zone</a> (<a class="el" href="structQPair.html">QPair</a> *qpair, uint64_t slba)</td></tr>
<tr class="memdesc:a8866709798a666f4dabfb3cf74ed4930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes a zone synchronously, preventing too many active zones.  <a href="szd_8h.html#a8866709798a666f4dabfb3cf74ed4930">More...</a><br /></td></tr>
<tr class="separator:a8866709798a666f4dabfb3cf74ed4930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17fbf4df6965a4fac44768ce735d1da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="szd_8h.html#ab17fbf4df6965a4fac44768ce735d1da">szd_get_zone_head</a> (<a class="el" href="structQPair.html">QPair</a> *qpair, uint64_t slba, uint64_t *write_head)</td></tr>
<tr class="memdesc:ab17fbf4df6965a4fac44768ce735d1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the write head of a zone synchronously as a logical block address (lba).  <a href="szd_8h.html#ab17fbf4df6965a4fac44768ce735d1da">More...</a><br /></td></tr>
<tr class="separator:ab17fbf4df6965a4fac44768ce735d1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca04e14f53974928b258eda0c443680"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="szd_8h.html#a6ca04e14f53974928b258eda0c443680">szd_get_zone_cap</a> (<a class="el" href="structQPair.html">QPair</a> *qpair, uint64_t slba, uint64_t *zone_cap)</td></tr>
<tr class="memdesc:a6ca04e14f53974928b258eda0c443680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the write head of a zone synchronously as a logical block address (lba).  <a href="szd_8h.html#a6ca04e14f53974928b258eda0c443680">More...</a><br /></td></tr>
<tr class="separator:a6ca04e14f53974928b258eda0c443680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797e15ef5ad4e7dff8d9b0096e6f234f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="szd_8h.html#a797e15ef5ad4e7dff8d9b0096e6f234f">szd_print_zns_status</a> (int status)</td></tr>
<tr class="memdesc:a797e15ef5ad4e7dff8d9b0096e6f234f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts status code of SZD to human readable messages.  <a href="szd_8h.html#a797e15ef5ad4e7dff8d9b0096e6f234f">More...</a><br /></td></tr>
<tr class="separator:a797e15ef5ad4e7dff8d9b0096e6f234f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1860eb2b13bf8f07b6ca7e54123ee565"><td class="memItemLeft" align="right" valign="top"><a id="a1860eb2b13bf8f07b6ca7e54123ee565"></a>
long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="szd_8h.html#a1860eb2b13bf8f07b6ca7e54123ee565">szd_spdk_strtol</a> (const char *nptr, int base)</td></tr>
<tr class="memdesc:a1860eb2b13bf8f07b6ca7e54123ee565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passthrough function that directly calls spdk_strtol, which is a helper for strings to unsigned longs. <br /></td></tr>
<tr class="separator:a1860eb2b13bf8f07b6ca7e54123ee565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c1b84ea347813e2ee311b9865a428d"><td class="memItemLeft" align="right" valign="top"><a id="a98c1b84ea347813e2ee311b9865a428d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>__szd_probe_probe_cb</b> (void *cb_ctx, const t_spdk_nvme_transport_id *trid, t_spdk_nvme_ctrlr_opts *opts)</td></tr>
<tr class="separator:a98c1b84ea347813e2ee311b9865a428d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7343cf72480cb13e1c6ff29f9137ca"><td class="memItemLeft" align="right" valign="top"><a id="afc7343cf72480cb13e1c6ff29f9137ca"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>__szd_probe_attach_cb</b> (void *cb_ctx, const t_spdk_nvme_transport_id *trid, struct spdk_nvme_ctrlr *ctrlr, const struct spdk_nvme_ctrlr_opts *opts)</td></tr>
<tr class="separator:afc7343cf72480cb13e1c6ff29f9137ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ebdd72c82190688699715776a14bcc"><td class="memItemLeft" align="right" valign="top"><a id="a33ebdd72c82190688699715776a14bcc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>__szd_open_create_private</b> (<a class="el" href="structDeviceManager.html">DeviceManager</a> *manager, <a class="el" href="structDeviceOpenOptions.html">DeviceOpenOptions</a> *options)</td></tr>
<tr class="separator:a33ebdd72c82190688699715776a14bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a042b8e40f6d109f6cba8258fb30738"><td class="memItemLeft" align="right" valign="top"><a id="a6a042b8e40f6d109f6cba8258fb30738"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>__szd_open_probe_cb</b> (void *cb_ctx, const t_spdk_nvme_transport_id *trid, t_spdk_nvme_ctrlr_opts *opts)</td></tr>
<tr class="separator:a6a042b8e40f6d109f6cba8258fb30738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c728e554f888823aaf5c4d9561c1af"><td class="memItemLeft" align="right" valign="top"><a id="aa9c728e554f888823aaf5c4d9561c1af"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>__szd_open_attach_cb</b> (void *cb_ctx, const t_spdk_nvme_transport_id *trid, t_spdk_nvme_ctrlr *ctrlr, const t_spdk_nvme_ctrlr_opts *opts)</td></tr>
<tr class="separator:aa9c728e554f888823aaf5c4d9561c1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e4f1fd31e73ac4ac06992ea3090d8e"><td class="memItemLeft" align="right" valign="top"><a id="ae5e4f1fd31e73ac4ac06992ea3090d8e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>__szd_open_remove_cb</b> (void *cb_ctx, t_spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="separator:ae5e4f1fd31e73ac4ac06992ea3090d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339755293e24e70b49d50f226dedcaee"><td class="memItemLeft" align="right" valign="top"><a id="a339755293e24e70b49d50f226dedcaee"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>__reserve_dma</b> (uint64_t size)</td></tr>
<tr class="separator:a339755293e24e70b49d50f226dedcaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4131718293d60b4f185e272d61e9eb8"><td class="memItemLeft" align="right" valign="top"><a id="ad4131718293d60b4f185e272d61e9eb8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>__operation_complete</b> (void *arg, const t_spdk_nvme_cpl *completion)</td></tr>
<tr class="separator:ad4131718293d60b4f185e272d61e9eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0309d92f364c4384aede5f03316851"><td class="memItemLeft" align="right" valign="top"><a id="aeb0309d92f364c4384aede5f03316851"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>__read_complete</b> (void *arg, const t_spdk_nvme_cpl *completion)</td></tr>
<tr class="separator:aeb0309d92f364c4384aede5f03316851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4873b0c7982dfe176ec97d0694aac0f"><td class="memItemLeft" align="right" valign="top"><a id="ab4873b0c7982dfe176ec97d0694aac0f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>__append_complete</b> (void *arg, const t_spdk_nvme_cpl *completion)</td></tr>
<tr class="separator:ab4873b0c7982dfe176ec97d0694aac0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdb42ac79a5eb0afdda5be63e870e7b"><td class="memItemLeft" align="right" valign="top"><a id="a8cdb42ac79a5eb0afdda5be63e870e7b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>__reset_zone_complete</b> (void *arg, const t_spdk_nvme_cpl *completion)</td></tr>
<tr class="separator:a8cdb42ac79a5eb0afdda5be63e870e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf40d8076d8160f0f3dd5b1dafb6d476"><td class="memItemLeft" align="right" valign="top"><a id="aaf40d8076d8160f0f3dd5b1dafb6d476"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>__finish_zone_complete</b> (void *arg, const t_spdk_nvme_cpl *completion)</td></tr>
<tr class="separator:aaf40d8076d8160f0f3dd5b1dafb6d476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab993affa4e67e3e8f9d1b3ac869073f6"><td class="memItemLeft" align="right" valign="top"><a id="ab993affa4e67e3e8f9d1b3ac869073f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>__get_zone_head_complete</b> (void *arg, const t_spdk_nvme_cpl *completion)</td></tr>
<tr class="separator:ab993affa4e67e3e8f9d1b3ac869073f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4918414b56facb90668bdd53bbae39a1"><td class="memItemLeft" align="right" valign="top"><a id="a4918414b56facb90668bdd53bbae39a1"></a>
const <a class="el" href="structDeviceOptions.html">DeviceOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DeviceOptions_default</b></td></tr>
<tr class="separator:a4918414b56facb90668bdd53bbae39a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd70da00731411fd503b73cb7bb863a"><td class="memItemLeft" align="right" valign="top"><a id="abfd70da00731411fd503b73cb7bb863a"></a>
const <a class="el" href="structDeviceOpenOptions.html">DeviceOpenOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DeviceOpenOptions_default</b></td></tr>
<tr class="separator:abfd70da00731411fd503b73cb7bb863a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053541e996f048caba0e57c39e3d5b7b"><td class="memItemLeft" align="right" valign="top"><a id="a053541e996f048caba0e57c39e3d5b7b"></a>
const <a class="el" href="structDeviceInfo.html">DeviceInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DeviceInfo_default</b></td></tr>
<tr class="separator:a053541e996f048caba0e57c39e3d5b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d67ada61cebd85b136228e7207ed88"><td class="memItemLeft" align="right" valign="top"><a id="aa5d67ada61cebd85b136228e7207ed88"></a>
const <a class="el" href="structDeviceManagerInternal.html">DeviceManagerInternal</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DeviceManagerInternal_default</b></td></tr>
<tr class="separator:aa5d67ada61cebd85b136228e7207ed88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca58e8605c31fb2b7b2bc7024f55ed76"><td class="memItemLeft" align="right" valign="top"><a id="aca58e8605c31fb2b7b2bc7024f55ed76"></a>
const <a class="el" href="structCompletion.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Completion_default</b></td></tr>
<tr class="separator:aca58e8605c31fb2b7b2bc7024f55ed76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main SZD interface. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a9e4664e9c4a10fed58725d3b2bb7c394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4664e9c4a10fed58725d3b2bb7c394">&#9670;&nbsp;</a></span>szd_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int szd_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQPair.html">QPair</a> *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append z_calloced data synchronously to a zone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>channel to use for I/O </td></tr>
    <tr><td class="paramname">lba</td><td>logical block address to write to (UNVERIFIED, but must equal write_head of zone), will be updated after each succesful write. </td></tr>
    <tr><td class="paramname">buffer</td><td>zcalloced data </td></tr>
    <tr><td class="paramname">size</td><td>size of buffer </td></tr>
    <tr><td class="paramname">nr_appends</td><td>ptr to variable that can be used for diagnostics, can be set to NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a58fc44339c4d312de8d1dd486ba900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a58fc44339c4d312de8d1dd486ba900">&#9670;&nbsp;</a></span>szd_append_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int szd_append_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQPair.html">QPair</a> *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCompletion.html">Completion</a> *&#160;</td>
          <td class="paramname"><em>completion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append z_calloced data asynchronously to a zone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>channel to use for I/O </td></tr>
    <tr><td class="paramname">lba</td><td>logical block address to write to (UNVERIFIED, but must equal write_head of zone), will be updated after each succesful write. </td></tr>
    <tr><td class="paramname">buffer</td><td>zcalloced data </td></tr>
    <tr><td class="paramname">size</td><td>size of buffer </td></tr>
    <tr><td class="paramname">nr_appends</td><td>ptr to variable that can be used for diagnostics, can be set to NULL. </td></tr>
    <tr><td class="paramname">completion</td><td>can be used to poll for completion later on (sync) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20543f2c42b5e892b24460902b76780f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20543f2c42b5e892b24460902b76780f">&#9670;&nbsp;</a></span>szd_create_qpair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int szd_create_qpair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDeviceManager.html">DeviceManager</a> *&#160;</td>
          <td class="paramname"><em>man</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structQPair.html">QPair</a> **&#160;</td>
          <td class="paramname"><em>qpair</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Qpair to be used for I/O oprations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair,pointer</td><td>to unallocated qpair pointer to be created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a695f046f9c36616bd492d94f56546505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695f046f9c36616bd492d94f56546505">&#9670;&nbsp;</a></span>szd_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int szd_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDeviceManager.html">DeviceManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the device if open and destroys the manager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">manager</td><td>non-null manager to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8866709798a666f4dabfb3cf74ed4930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8866709798a666f4dabfb3cf74ed4930">&#9670;&nbsp;</a></span>szd_finish_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int szd_finish_zone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQPair.html">QPair</a> *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>slba</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes a zone synchronously, preventing too many active zones. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>channel to use for I/O </td></tr>
    <tr><td class="paramname">slba</td><td>starting logical block address of zone to reset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ca04e14f53974928b258eda0c443680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca04e14f53974928b258eda0c443680">&#9670;&nbsp;</a></span>szd_get_zone_cap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int szd_get_zone_cap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQPair.html">QPair</a> *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>slba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>zone_cap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the write head of a zone synchronously as a logical block address (lba). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>channel to use for I/O </td></tr>
    <tr><td class="paramname">slba</td><td>starting logical block address of zone to get the write head from. </td></tr>
    <tr><td class="paramname">zone_cap</td><td>capacity of a zone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab17fbf4df6965a4fac44768ce735d1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17fbf4df6965a4fac44768ce735d1da">&#9670;&nbsp;</a></span>szd_get_zone_head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int szd_get_zone_head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQPair.html">QPair</a> *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>slba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>write_head</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the write head of a zone synchronously as a logical block address (lba). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>channel to use for I/O </td></tr>
    <tr><td class="paramname">slba</td><td>starting logical block address of zone to get the write head from. </td></tr>
    <tr><td class="paramname">write_head</td><td>pointer to store the write head in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7342bc46d1eab59316ac49b8653c8e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7342bc46d1eab59316ac49b8653c8e5">&#9670;&nbsp;</a></span>szd_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int szd_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDeviceManager.html">DeviceManager</a> **&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDeviceOptions.html">DeviceOptions</a> *&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inits SPDK and the general device manager, always call ONCE before ANY other function is called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">manager</td><td>pointer to manager that will be initialised. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a797e15ef5ad4e7dff8d9b0096e6f234f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a797e15ef5ad4e7dff8d9b0096e6f234f">&#9670;&nbsp;</a></span>szd_print_zns_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void szd_print_zns_status </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts status code of SZD to human readable messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>If an SZD code retun appropriate message, else return default message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fa391fd5dd04e707bb2911fee07f0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa391fd5dd04e707bb2911fee07f0b8">&#9670;&nbsp;</a></span>szd_probe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int szd_probe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDeviceManager.html">DeviceManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structProbeInformation.html">ProbeInformation</a> **&#160;</td>
          <td class="paramname"><em>probe_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>probes all devices that can be attached by SPDK and set probing information for them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">probe</td><td>sets to be a list of information on all attachable devices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06221d02ad2597c708adbdfba3dc526b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06221d02ad2597c708adbdfba3dc526b">&#9670;&nbsp;</a></span>szd_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int szd_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQPair.html">QPair</a> *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads n bytes synchronously from the ZNS device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>channel to use for I/O </td></tr>
    <tr><td class="paramname">lba</td><td>logical block address to read from (can read in non-written areas) </td></tr>
    <tr><td class="paramname">buffer</td><td>zcalloced buffer to store the read data in. </td></tr>
    <tr><td class="paramname">size</td><td>Amount of data to read in bytes (lba_size alligned) </td></tr>
    <tr><td class="paramname">nr_reads</td><td>ptr to variable that can be used for diagnostics, can be set to NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ae42d963fff9f81ad88321f3b7ad287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae42d963fff9f81ad88321f3b7ad287">&#9670;&nbsp;</a></span>szd_reinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int szd_reinit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDeviceManager.html">DeviceManager</a> **&#160;</td>
          <td class="paramname"><em>manager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Only works when device is not NULL, it recreates the device context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">manager</td><td>akready existing manager to recreate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2f56bc7a4bda5299058503586f81d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f56bc7a4bda5299058503586f81d6a">&#9670;&nbsp;</a></span>szd_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int szd_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQPair.html">QPair</a> *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>slba</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets a zone synchronously, allowing it to be reused. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>channel to use for I/O </td></tr>
    <tr><td class="paramname">slba</td><td>starting logical block address of zone to reset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
